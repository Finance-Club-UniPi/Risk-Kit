import numpy as np


def _to_2d_array(x):
    arr = np.asarray(x, dtype=float)
    if arr.ndim == 1:
        arr = arr.reshape(-1, 1)
    if arr.size == 0:
        raise ValueError("Input returns array is empty.")
    if arr.shape[0] < 2:
        raise ValueError("Need at least 2 time points.")
    return arr


def estimate_mean_cov(returns, annualization_factor=252):
    r = _to_2d_array(returns)
    mu = np.mean(r, axis=0) * annualization_factor
    cov = np.cov(r, rowvar=False, ddof=1) * annualization_factor
    return mu, cov


def portfolio_return(weights, mu):
    w = np.asarray(weights, dtype=float).reshape(-1)
    m = np.asarray(mu, dtype=float).reshape(-1)
    if w.shape[0] != m.shape[0]:
        raise ValueError("Dimension mismatch.")
    return float(w @ m)


def portfolio_volatility(weights, cov):
    w = np.asarray(weights, dtype=float).reshape(-1)
    c = np.asarray(cov, dtype=float)
    if c.shape[0] != c.shape[1]:
        raise ValueError("Covariance must be square.")
    if w.shape[0] != c.shape[0]:
        raise ValueError("Dimension mismatch.")
    var = float(w @ c @ w)
    return float(np.sqrt(max(var, 0.0)))


def global_minimum_variance_portfolio(cov):
    c = np.asarray(cov, dtype=float)
    n = c.shape[0]
    if c.shape[0] != c.shape[1]:
        raise ValueError("Covariance must be square.")
    ones = np.ones(n)
    inv_c = np.linalg.pinv(c)
    w = (inv_c @ ones) / (ones @ inv_c @ ones)
    return w


def efficient_frontier_weights(mu, cov, target_return):
    m = np.asarray(mu, dtype=float).reshape(-1)
    c = np.asarray(cov, dtype=float)
    n = m.shape[0]
    if c.shape != (n, n):
        raise ValueError("Dimension mismatch.")
    ones = np.ones(n)
    inv_c = np.linalg.pinv(c)
    A = float(ones @ inv_c @ ones)
    B = float(ones @ inv_c @ m)
    C = float(m @ inv_c @ m)
    D = A * C - B * B
    if abs(D) < 1e-14:
        raise ValueError("Degenerate system.")
    lam = (C - B * target_return) / D
    gam = (A * target_return - B) / D
    w = inv_c @ (lam * ones + gam * m)
    return w


def tangency_portfolio(mu, cov, risk_free_rate=0.0):
    m = np.asarray(mu, dtype=float).reshape(-1)
    c = np.asarray(cov, dtype=float)
    excess = m - risk_free_rate
    inv_c = np.linalg.pinv(c)
    raw = inv_c @ excess
    denom = float(np.sum(raw))
    if abs(denom) < 1e-14:
        raise ValueError("Cannot normalize weights.")
    return raw / denom


def efficient_frontier(mu, cov, n_points=25):
    m = np.asarray(mu, dtype=float).reshape(-1)
    targets = np.linspace(float(np.min(m)), float(np.max(m)), int(n_points))
    rets = []
    vols = []
    weights_list = []
    for tr in targets:
        w = efficient_frontier_weights(m, cov, tr)
        rets.append(portfolio_return(w, m))
        vols.append(portfolio_volatility(w, cov))
        weights_list.append(w)
    return np.array(rets), np.array(vols), weights_list


if __name__ == "__main__":
    rng = np.random.default_rng(42)
    R = rng.normal(0.0005, 0.01, size=(1000, 3))
    mu, cov = estimate_mean_cov(R)
    w = tangency_portfolio(mu, cov, risk_free_rate=0.02)
    print(w)
    print(portfolio_return(w, mu))
    print(portfolio_volatility(w, cov))
